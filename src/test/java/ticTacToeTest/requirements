Gra w K贸ko i krzy偶yk powinna powinna si skada z nastpujcych klas:

1. Klasa przechowujca dane o planszy. Powinna zawiera testy:

    - sprawdzajcy, czy da si utworzy now plansze

    - czy nowa plansza zawiera puste wartoci

    - czy da si doda prawidowy ruch

    - czy da si doda dwa razy taki sam ruch

    - czy da si doda nieprawidowy ruch (rozwa偶y przypadki podania niepoprawnych koordynat贸w oraz niepoprawnego symbolu)

    - czy da si pobra element planszy o prawidowym adresie

    - czy da si pobra element planszy o nieprawidowym adresie

2. Klas sprawdzajc, czy dala plansza jest ju偶 rozwizana (czy kt贸ry z graczy wygra). Testy:

    - czy dla pustej planszy metoda sprawdzajca zwraca informacje o tym, 偶e nikt nie wygra

    - czy je偶eli w kt贸rymkolwiek z wierszy s 3 symbole jednego gracza, to czy zwracany jest symbol tego gracza

    - czy je偶eli w kt贸rejkolwiek z kolumn s 3 symbole jednego gracza, to czy zwracany jest symbol tego gracza

    - czy je偶eli na kt贸rejkolwiek przektnej s 3 symbole jednego gracza, to czy zwracany jest symbol tego gracza

3. Klas gracza ludzkiego

    - sprawdzi, czy da si utworzy tak klas (rozwa偶y, czy powinna ona mie konstruktor bezparametrowy, czy mo偶e powinna wymaga jakiej wartoci)

    - czy po wpisaniu wartosci na strumien wejsciowy jest zwracany poprawny adres kom贸rki planszy

4. Klas gracza automatycznego

    - sprawdzi, czy da si utworzy tak klas

    - czy dla r贸偶nych przypadk贸w planszy jest zwracany poprawny adres kom贸rki (czy jest w odpowiednim zakresie oraz czy nie pr贸buje wybra pola ju偶 zajtego)

    BONUS: rozwa偶y wydzielenie dla graczy wsp贸lnego interface lub klasy abstrakcyjnej

5. Klas zarzdzajc gr

    - sprawdzi, czy da si utworzy tak klas (rozwa偶y, czy powinna ona mie konstruktor bezparametrowy, czy mo偶e powinna wymaga jakiej wartoci)

    - sprawdzi, czy pobiera ruch od gracza

    - sprawdzi, czy pobiera ruchy od graczy naprzemiennie

    - sprawdzi, czy przestaje pobiera ruch od gracza, gdy gra zostanie zakoczona (wygrana jednego z graczy lub przez remis)

    - sprawdzic, czy przekazuje pobrane od gracza koordynaty ruchu do planszy

    - sprawdzic, czy przekazuje do planszy prawidowy symbol gracza

    - sprawdzi, czy po wykonaniu ruchu waliduje wygran kt贸rego z graczy

    - sprawdzi, czy jest zwyciezca i  zwr贸cenie symbolu gracza

    - sprawdzi, czy gra zakonczyla sie remisem

    - sprawdzi, czy gra zostala porzucona

6. Klas, kt贸ra wywietla plansz

    - jak wywietla plansz, kiedy jest pusta

    - jak wywietla plansz, kiedy jest cakowicie zapeniona

    - jak wywietla plansz, kiedy zawiera kilka ustawionych p贸l

7. Klas, kt贸ra wywietla menu gry

    - sprawdzi, czy wypisuje odpowiednie komunikaty dla u偶ytkownika z menu

    - sprawdzi, czy wykonuje prawidowe operacje (utworzenie obiekt贸w i przekazanie ich do zale偶nych klas) po wybraniu opcji nowej gry

8. Klas, kt贸ra uruchamia gr (ticTacToe.Main)

9. Wykorzystac dla testow junitparams.

10. Sprobowac w wybranych testach wykorzystac mockito.

String nonArtificialPlayer = this.player.getXorO();
        if(nonArtificialPlayer.equals("X")){
            this.XorO = "O";
        }else {
            this.XorO = "X";
        }


        String[][] givenBoard = new String[3][3];
                String[] strings = {"X", "X", "X"};
                Arrays.fill(givenBoard, strings);
                Board board = new Board(givenBoard);
                ArtificialPlayer artificialPlayer = new ArtificialPlayer("O",board);

                System.out.println(board.getMyBoard()[0][1]);
                givenBoard[1][1] = "kk ";
                System.out.println(board.getMyBoard()[2][1]);
                int[] expected = {1,1};


Code review tego co masz wypchnite na githubie 

1. Board.java
- myBoard - private
- takeField -> markField - zaznaczasz pole a nie bierzesz
- X -> row, Y -> column - te nazwy od razu m贸wi o co chodzi, X i Y nie s a偶 tak wymowne, poza tym p贸藕niej masz XorO - czym si te dwa X r贸偶ni?
///////// Player player -> String sign - nie potrzebny Ci gracz, chcesz tylko da odpowiedni znak
///////// i nastpnie trzeba doda walidacj czy znak jest poprawny (X lub O)
- jest taka metodyka, kt贸ra nazywa si early exit - chodzi o to, 偶eby nie robi if(A) { if (B) { if (C) { zrob cos } } } tylko raczej if (!A) { return; } if (!B) { return; } if (!C) { return; } zrob cos; - czyli u Ciebie by byo tak:

if (row < 0 || row >= myBoard.length || column < 0 || column >= myBoard[row].length) {
    System.out.println("Positions out of bounds");
    return false;
}

if (!myBoard[row][column].equals(" ")) {
    return false;
}

myBoard[row][column] = sign;

2. CheckIfGameIsOver
- nie wiem czy over to dobre sowo, mo偶e lepiej finished?
- board, player - private
- checkBoard - co to jest?
- checkIfTheWinner -> getWinner - zwracasz ten znak wic chyba lepiej napisa co zwracasz, poza tym to chyba taka konwencja bardziej
//////- String[][] myBoard -> eee, raczej chcesz tu przekaza Board board
- i -> row, j -> column
- wyglda na to, 偶e k ma zawsze warto 0
 nie korzystasz nigdzie z j (column) - mo偶e ten jeden for jest niepotrzebny?
- collumn - jedno l, i ten komentarz jest troch przesunity
- w tym if po collumn w rodku masz zy indeks - myBoard[i+1][i]
- across nie s zale偶ne ani od i ani od j, mo偶e nie ma sensu ich powtarza w ka偶dej iteracji fora?

3. Player.java
- board do wywalenia a XorO private
- chooseField - askForCoordinates
- splitParseMove - samo parse wystarczy, ale bym da parseCoordinates
- splitParseMove - jak kole da np tylko "1" - to program si wywali w tej metodzie po results[1] bdzie poza rozmiarem
- splitParseMove - jakie spacje po i przed klamrami?
- setter dla XorO niepotrzebny - to jest co co ustawiasz w konstruktorze i nie chcesz tego zmienia p贸藕niej

4. BoardTests.java
- shouldMakeNewBoard - notExpectedBoard niepotrzebne, przecie偶 sprawdzasz czy jest r贸wne do expected, nie bdzie jednoczenie r贸wne do notExpected, tak samo to isNotNull jest niepotrzebne bo jak bdzie tymi pustymi to te偶 nie bdzie nullem
- shouldMakeAmove -> shouldMakeMove - tych 'a' raczej nie u偶ywa si w nazwach metod
- fieldToCHeck -> fieldToCheck
- check -> verify, raczej w testach u偶ywa si s贸wka verify
- to expectedBoard w tej metodzie jest niepotrzebne, potrzebujesz tylko String expectedCharacter = "X";
- shouldNotTakeAwrongFieldOutOfBounds -> shouldNotTakeFieldOutOfBounds

//
5. CheckIfGameIsOverTest.java
- Board przyjmuje w konstruktorze String[][] wic skorzystajmy z tego zamiast woa takeField, w razie jakby ta metoda takeField przestaa dziaa to niepotrzebnie te testy r贸wnie偶 przestan dziaa chocia偶 w CheckIfGameIsOver nigdzie w niej nie korzystasz
- shouldInform -> raczej po prostu shouldReturnFalse, jak bdziecie robi wzorce projektowe to si dowiesz, 偶e inform to mo偶e by np 'rozmawianie' dw贸ch obiekt贸w ze sob, jeden bdzie informowa drugi, 偶e co si stao. A tutaj po prostu zwracasz warto z funkcji
- NobodyWins -> raczej NowbodyWon raczej czas dokonany
- shouldReturnWinnerIfrowsIsTaken - chyba IfRowIsTaken - to w og贸le dobre miejsce na fora, mo偶esz sprawdzi czy dla ka偶dego rzdu faktycznie zwr贸ci X
- analogicznie dla ColumnsAreTaken

6. PlayerTest.java
- tak jak rozmawialimy, Scanner powinien by 'wstrzyknity' jako zale偶no, kt贸rej faktycznie nie chcemy testowa - to si nazywa dependency injection
nie chce zmockowac scannera
